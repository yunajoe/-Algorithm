def solution(arr):
    duplicated_index = [i+1 for i in range(len(arr)-1) if arr[i] == arr[i+1]]    
   return [arr[i] for i in range(len(arr)) if i not in duplicated_index]
 

정확성: 71.9
효율성: 0.0
합계: 71.9 / 100.0

==========================================================================================
# Try 2

def solution(arr):
    stack = []
    for num in arr:
        if num not in stack:
            stack.append(num)
        elif stack[-1] != num:
            stack.append(num)
    return stack

==========================================================================================
# 시도 1
from collections import deque
def solution(arr):
    queue = deque()
    # [실행] 버튼을 누르면 출력 값을 볼 수 있습니다.
    for i in range(len(arr)):
        queue.append(arr.pop(i))
        if queue[-1] == arr[i]:
            continue
        queue.append(arr.pop(i))
        if i < len(arr):
            break
    return queue
        
# 시도 2
def solution(arr):
    idx = 0     
    result = []
    length = len(arr)
    while len(arr) != 0: 
        if len(result) == 0:
            num = arr.pop(idx)
            result.append(num)
        else:
            if result[-1] == arr[idx]:
                idx += 1
                if idx >= len(arr):
                    break
            else:
                result.append(arr.pop(idx))
    return result
    
    
    
===================================================================
   
    
def solution(arr):
    idx = 0 
    result = []
    while len(arr) != 0:
        if len(result) == 0:
            result.append(arr[idx])    
            arr.pop(idx)    
        else:
            if result[-1] ==  arr[idx]:
                arr.pop(idx)
                
            else:
                result.append(arr[idx])
                arr.pop(idx)
    return arr
    
채점 결과
정확성: 71.9
효율성: 0.0
합계: 71.9 / 100.0
    
    
    

 
        
