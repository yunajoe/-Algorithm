

# n보다 money_list2의 len()이 큰 경우와, 작은 경우로 나뉠 수 있다 

def solution(n, money_list):
    profit_table = []
    for i in range(n):
        if i < len(money_list): # n이 money_list의 인덱스에 다 포함될때.. 
            profit = money_list[i]
        else:
            # 그 값이 없으면 모든 경우의 수를 
            profit = 0 # 얘는 max(profit, ...) 처럼 비교하기 위해서                             
        
        for j in range((i//2)+1):
            profit = max(profit, money_list[j] + money_list[i-j])              
        profit_table.append(profit)
        
    return profit_table[n-1]
            
          
if __name__ == "__main__":
    n = int(input())
    money = list(map(int, input().split()))
    print(solution(n, money))


# 틀림 


=================================================================================== 




# n보다 money_list2의 len()이 큰 경우와, 작은 경우로 나뉠 수 있다 

def solution(n, money_list):
    profit_table = []
    for i in range(1,n):
        if i < len(money_list): # n이 money_list의 인덱스에 다 포함될때.. 
            profit = money_list[i]
        else:
            # 그 값이 없으면 모든 경우의 수를 
            profit = 0 # 얘는 max(profit, ...) 처럼 비교하기 위해서                             
        
        for j in range(i,n):
            if i + j <=n:
                profit = money_list[i-1] + money_list[j-1]
            profit_table.append(profit)
        
    return profit_table[n-1]
            
          
if __name__ == "__main__":
    n = int(input())
    money = list(map(int, input().split()))
    print(solution(n, money))

            
    
 또트릶.
 
 n = 4 
lis = [1,5,6,7]
lis.insert(0,0)
profit_table =[]
# n이 lis안에 포함이 될려면 len(lis)는 최소 n+1개가 되어야 한다. b/c 0부터 시작이니까
for i in range(1,n+1): # i는 0,1,2,3,4
    if i < len(lis):  # lis안에 있는 원소들을 최대값이랑 생각하고 일단 다 채워주기  
        profit_table.append(lis[i])         
    else:  # 이때는 경우의 수를 생각해서 max를 넣어줌 
        profit = 0         
    for j in range(1,(i//2)+1):  # 0을 뺸 이유는 위에서 이미 채워줬기 때문 
        answer = max(profit, lis[i-j] + lis[j])
        print(answer)
        
        
    
